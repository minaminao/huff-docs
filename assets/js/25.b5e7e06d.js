(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{454:function(t,e,a){"use strict";a.r(e);var n=a(66),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"the-basics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-basics"}},[t._v("#")]),t._v(" The Basics")]),t._v(" "),a("h2",{attrs:{id:"installation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#installation"}},[t._v("#")]),t._v(" Installation")]),t._v(" "),a("p",[t._v("Huffを書き始める前に、コンパイラをインストールする必要があります。"),a("a",{attrs:{href:"https://docs.huff.sh/get-started/overview/",target:"_blank",rel:"noopener noreferrer"}},[t._v("getting started"),a("OutboundLink")],1),t._v("に移動して、手順に従ってインストールしてください。\n完了したら、ここに戻って来てください!")]),t._v(" "),a("h2",{attrs:{id:"what-you-are-going-to-learn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-you-are-going-to-learn"}},[t._v("#")]),t._v(" What you are going to learn?")]),t._v(" "),a("p",[t._v('他のプログラミング言語と違って、"Hello, world!" を返すハフコントラクトを作るのは、かなり高度なことです。ここでは、2つの数字を足すハフコントラクトを作る方法を学びます（その後、"Hello, world!）\nエディタを開いて、'),a("code",[t._v("addTwo.huff")]),t._v("というファイルを作ってください。さあ、はじめましょう。")]),t._v(" "),a("h2",{attrs:{id:"add-two"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#add-two"}},[t._v("#")]),t._v(" Add Two")]),t._v(" "),a("h3",{attrs:{id:"abi-declaration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-declaration"}},[t._v("#")]),t._v(" ABI declaration")]),t._v(" "),a("p",[t._v("まずはじめに。SolidityやVyperのような高級言語から来た人は、「外部」または「公開」関数の定義に慣れていると思います。これらは、ABI (Application Binary Interface) を生成することによって、コントラクトと外部で対話することを可能にします。これは、外部ツールに対するコントラクトのエントリーポイントを記述するものです（これについては後で詳しく説明します）。この点ではHuffは全く同じで、ファイルの一番上のabiに表示される関数を宣言することができます。")]),t._v(" "),a("div",{staticClass:"language-Huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#define function addTwo(uint256, uint256) view returns(uint256)\n")])])]),a("p",[t._v("先に進んで、上記の例を"),a("code",[t._v("addTwo.huff")]),t._v("の先頭に貼り付けてください。これは、2つの"),a("code",[t._v("uint256")]),t._v("入力を受け取り、1つの"),a("code",[t._v("uint256")]),t._v("を返す関数を宣言しています。")]),t._v(" "),a("h3",{attrs:{id:"the-main-macro"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-main-macro"}},[t._v("#")]),t._v(" The Main Macro")]),t._v(" "),a("p",[t._v("次に作成するのは、"),a("code",[t._v("MAIN macro")]),t._v("です。これはハフコントラクトの単一のエントリポイントとして機能します。コントラクトへのすべての呼び出しは(どのような関数を呼び出しているかに関わらず)、"),a("code",[t._v("MAIN")]),t._v(" から始まることになります!この例では、calldata から 2 つの "),a("code",[t._v("uint256")]),t._v(" を読み込み、その結果を返す "),a("code",[t._v("MAIN")]),t._v(" 関数を定義する。")]),t._v(" "),a("div",{staticClass:"language-Huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#define macro MAIN() = takes(0) returns(0) {\n    0x00 calldataload     // [number1] // load first 32 bytes onto the stack - number 1\n    0x20 calldataload     // [number2] // load second 32 bytes onto the stack - number 2\n    add                   // [number1+number2] // add number 1 and 2 and put the result onto the stack\n\n    0x00 mstore           // place [number1 + number2] in memory\n    0x20 0x00 return      // return the result\n}\n")])])]),a("p",[t._v("上の図を見ると、最初は戸惑うかもしれませんが、我慢してください。")]),t._v(" "),a("p",[t._v("MAIN 命令が "),a("code",[t._v("takes(0) returns(0)")]),t._v(" で注釈されていることに気がつくでしょう。EVMはスタックベースの仮想マシン（参照："),a("a",{attrs:{href:"https://docs.huff.sh/tutorial/evm-basics/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Understanding the EVM"),a("OutboundLink")],1),t._v("）なので、すべてのマクロ宣言には、スタックから"),a("code",[t._v("take")]),t._v("するアイテムの数と完了時に"),a("code",[t._v("return")]),t._v("する量がアノテーションされています。契約に入るとき、スタックは空である。完了時にはスタックに何も残さないので、take と return は共に 0 になる。")]),t._v(" "),a("p",[t._v("先に、上記のマクロを"),a("code",[t._v("addTwo.huff")]),t._v("ファイルにコピーしておいてください。"),a("code",[t._v("huffc addTwo.huff --bytecode")]),t._v("を実行します。")]),t._v(" "),a("p",[t._v("おめでとうございます！最初の契約がまとまりましたね。")]),t._v(" "),a("p",[t._v("コンパイラのバイトコード出力は、コンソールに次のようにエコーされます "),a("code",[t._v("600f8060093d393df36000356020350160005260206000f3")]),t._v(".")]),t._v(" "),a("p",[t._v("このコントラクトコードをデプロイすると、先ほど作成したメインマクロのランタイムバイトコードが含まれます!上記のスニペットでは、最初の "),a("code",[t._v("f3")]),t._v(" の後にあります (前のバイトコードはボイラープレートのコンストラクタのロジックです)。\nつまり、次のようになります。"),a("code",[t._v("6000356020350160005260206000f3")]),t._v("\n以下、この例では作成したものを分解しています。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" BYTECODE          MNEMONIC         STACK                 ACTION\n 60 00          // PUSH1 0x00       // [0x00]\n 35             // CALLDATALOAD     // [number1]          Store the first 32 bytes on the stack\n 60 20          // PUSH1 0x20       // [0x20, number1]\n 35             // CALLDATALOAD     // [number2, number1] Store the second 32 bytes on the stack\n 01             // ADD              // [number2+number1]  Take two stack inputs and add the result\n 60 00          // PUSH1 0x00       // [0x0, (n2+n1)]\n 52             // MSTORE           // []                 Store (n2+n1) in the first 32 bytes of memory\n 60 20          // PUSH1 0x20       // [0x20]\n 60 00          // PUSH1 0x00       // [0x00, 0x20]\n f3             // RETURN           // []                 Return the first 32 bytes of memory\n")])])]),a("p",[t._v("もし自分で実行したい場合は、このスニペットを"),a("a",{attrs:{href:"https://www.evm.codes/playground?unit=Wei&codeType=Bytecode&code='~3560203501~526020~f3'~6000%01~_",target:"_blank",rel:"noopener noreferrer"}},[t._v("evm.codes"),a("OutboundLink")],1),t._v("で対話的にチェックすることができます（calldata "),a("code",[t._v("0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002")]),t._v("を渡してRUNをクリックすると開始されます）。この calldata は数字 1 と 2 で、両方とも 32 バイトにパディングされています。このスニペットを実行すると、"),a("code",[t._v("0000000000000000000000000000000000000000000000000000000000000003")]),t._v("という戻り値が得られるはずです。これは期待通りです。"),a("code",[t._v("addTwo.huff")]),t._v("は1番と2番を足して3番を返すことに成功しました!もしあなたがアセンブリに慣れていないなら、個々の命令を視覚化することが学習に非常に役立つので、これを実行することを強くお勧めします。")]),t._v(" "),a("p",[t._v("次のセクションでは、2 + 3 の calldata が提供されたと仮定して、コントラクトの実行を説明する。uint256（32バイト）にエンコードすると、2は"),a("code",[t._v("0000000000000000000000000000000000000000000000000000000000000002")]),t._v("に、3は"),a("code",[t._v("0000000000000000000000000000000000000000000000000000000000000003")]),t._v("になる。")]),t._v(" "),a("p",[t._v("これを図にすると、下の表のようになります。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Type")]),t._v(" "),a("th",[t._v("Value")]),t._v(" "),a("th",[t._v("As calldata")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("uint256")]),t._v(" "),a("td",[t._v("2")]),t._v(" "),a("td",[t._v("0000000000000000000000000000000000000000000000000000000000000002")])]),t._v(" "),a("tr",[a("td",[t._v("uint256")]),t._v(" "),a("td",[t._v("3")]),t._v(" "),a("td",[t._v("0000000000000000000000000000000000000000000000000000000000000003")])])])]),t._v(" "),a("p",[t._v("この2つを組み合わせることで、以下のようなcalldataをコントラクトに送ることになる。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("0x00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003\n")])])]),a("h3",{attrs:{id:"execution-walk-through"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#execution-walk-through"}},[t._v("#")]),t._v(" Execution Walk Through")]),t._v(" "),a("p",[a("em",[a("strong",[t._v("Line 1:")])]),t._v(" "),a("code",[t._v("0x00 calldataload")])]),t._v(" "),a("p",[t._v("この行は calldata の最初の 32 バイトをスタックに読み取ります。"),a("code",[t._v("calldataload")]),t._v(" オペコードはスタックから calldata のオフセットを入力として受け取り、そのオフセットから 32 バイトをスタックに返します。")]),t._v(" "),a("p",[a("em",[t._v("Stack after operation:")]),t._v(" "),a("code",[t._v("[2]")])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("em",[a("strong",[t._v("Line 2:")])]),t._v(" "),a("code",[t._v("0x20 calldataload")])]),t._v(" "),a("p",[t._v("同様に、2行目ではcalldataの2番目の32バイトを読み込んでいます。16進数の"),a("code",[t._v("0x20")]),t._v("（32）をトリガーの"),a("code",[t._v("calldataload")]),t._v("に押し付けることで、このようになります。")]),t._v(" "),a("p",[a("em",[t._v("Stack after operation:")]),t._v(" "),a("code",[t._v("[3,2]")])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("em",[a("strong",[t._v("Line 3:")])]),t._v(" "),a("code",[t._v("add")])]),t._v(" "),a("p",[t._v("3 行目では、add オペコードを呼び出しています。これは、スタックから上位 2 つの項目を入力として受け取り、それら 2 つの数値の合計を返します。入力が "),a("code",[t._v("[3,2]")]),t._v(" の場合、結果は "),a("code",[t._v("[5]")]),t._v(" になります。")]),t._v(" "),a("p",[a("em",[t._v("Stack after operation")]),t._v(" "),a("code",[t._v("[5]")])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("em",[a("strong",[t._v("Lines 4 and 5")])]),t._v("\nコントラクトの残りの部分は、結果を返すことに関係しています。EVMコントラクトは、現在の実行メモリフレーム内に格納されている値のみを返すことができます。これは、returnオペコードが2つの値を入力として受け取るためである。復帰を開始するメモリのオフセットと、復帰するメモリの長さです。\nこの場合、"),a("code",[t._v("return")]),t._v("オペコードは"),a("code",[t._v("[0x00, 0x20]")]),t._v("を消費する。つまり、0バイトから始まる32バイトのメモリを消費します。")]),t._v(" "),a("p",[t._v("これは、"),a("code",[t._v("0x00 mstore")]),t._v("が何のためにあるのかを説明しています。"),a("code",[t._v("mstore")]),t._v(" はスタックから 2 つのアイテムを取り、"),a("code",[t._v("[location_in_memory, value]")]),t._v(" とします。この例では"),a("code",[t._v("[0x00, 0x5]")]),t._v("があり、これは値5をメモリに格納します。")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"interacting-with-this-contract-externally"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interacting-with-this-contract-externally"}},[t._v("#")]),t._v(" Interacting with this contract externally")]),t._v(" "),a("p",[t._v("前述したように、EVMコントラクトは、どの関数を呼び出すべきかを決定するためにABIを使用します。現在、addTwoの実行と対話する人は、線形であり、1つの機能しか許可しません。ほとんどのコントラクトは、複数の関数を持ちたいと思うでしょう。これに対応するために、私たちは少し再構築する必要があるでしょう。")]),t._v(" "),a("p",[t._v("コントラクトのABI仕様では、コントラクトの呼び出しは、呼び出しに4バイト（関数セレクタ）を付加することによって、どの関数を呼び出したいかを選択することになっている。この4バイトは、関数のABI定義のケチャックの先頭からスライスされています。例えば、"),a("code",[t._v("addTwo(uint256,uint256)")]),t._v("のファンクションセレクタは"),a("code",[t._v("0x0f52d66e")]),t._v("になります（"),a("a",{attrs:{href:"https://book.getfoundry.sh/cast/",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("cast")]),a("OutboundLink")],1),t._v("の"),a("code",[t._v("sig")]),t._v("コマンドなどのコマンドラインツールや、"),a("a",{attrs:{href:"https://emn178.github.io/online-tools/keccak_256.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("keccak256 online"),a("OutboundLink")],1),t._v("などのオンラインサイトで確認することができます）。もし、これらがどのようなものか興味があれば、"),a("a",{attrs:{href:"https://www.4byte.directory/",target:"_blank",rel:"noopener noreferrer"}},[t._v("4 byte directory"),a("OutboundLink")],1),t._v("に一般的な4バイトのファンクションセレクタのレジストリが掲載されています。")]),t._v(" "),a("p",[t._v("ファンクションセレクタを毎回計算するのは面倒なことです。そこで、huff には "),a("code",[t._v("__FUNC_SIG()")]),t._v(" という組み込み関数が用意されています。ファイルの現在のスコープ内で関数インターフェイスが宣言されていれば、その関数セレクタを計算してインライン化してくれるのです。huffの組み込み関数についての詳細は"),a("RouterLink",{attrs:{to:"/get-started/huff-by-example/#func-sig-func-def-string"}},[t._v("here")]),t._v("を参照してください。")],1),t._v(" "),a("h4",{attrs:{id:"modifying-our-contract-to-accept-external-function-calls"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modifying-our-contract-to-accept-external-function-calls"}},[t._v("#")]),t._v(" Modifying our contract to accept external function calls")]),t._v(" "),a("p",[t._v("複数の関数の外部呼び出しを受け入れるには、"),a("code",[t._v("addTwo")]),t._v(" のロジックを別のマクロに抽出する必要があります。次に、"),a("code",[t._v("MAIN")]),t._v(" マクロを関数ディスパッチャに変換します。")]),t._v(" "),a("div",{staticClass:"language-Huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("#define function addTwo(uint256,uint256) view returns(uint256)\n\n#define macro MAIN() = takes(0) returns(0) {\n\n    // Get the function selector\n    0x00\n    calldataload\n    0xE0\n    shr\n\n    // Jump to the implementation of the ADD_TWO function if the calldata matches the function selector\n    __FUNC_SIG(addTwo) eq addTwo jumpi\n\n    addTwo:\n        ADD_TWO()\n}\n\n#define macro ADD_TWO() = takes(0) returns(0) {\n    0x04 calldataload     // load first 32 bytes onto the stack - number 1\n    0x24 calldataload     // load second 32 bytes onto the stack - number 2\n    add                   // add number 1 and 2 and put the result onto the stack\n\n    0x00 mstore           // place the result in memory\n    0x20 0x00 return      // return the result\n}\n")])])]),a("p",[t._v("最初に行う変更は、ADD_TWO マクロの中で行われます。これは calldata の値の前に 4 バイトの関数セレクタを付加するためです。")]),t._v(" "),a("p",[a("code",[t._v("MAIN")]),t._v(" マクロが大きく変わりました。\n最初の 4 行は、関数セレクタを calldata から切り離すことに関係しています。")]),t._v(" "),a("ol",[a("li",[a("p",[a("code",[t._v("0x00")]),t._v(" が "),a("code",[t._v("[0]")]),t._v(" をスタックにプッシュ")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("calldataload")]),t._v(" は "),a("code",[t._v("[0]")]),t._v(" を入力とし、最初の 32 バイトの calldata をスタックにプッシュする。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("0xE0")]),t._v(" は "),a("code",[t._v("[224]")]),t._v(" をスタックにプッシュします。このマジックナンバーは256ビット-32ビット(28バイト)を表しています。")])]),t._v(" "),a("li",[a("p",[t._v("この後shrを実行すると、calldataが28バイトシフトされ、関数セレクタがスタックに配置されます。")])])]),t._v(" "),a("p",[t._v("次の行は、スタック上の関数セレクタにマッチして、そのコードのある場所にジャンプします。ジャンプロジックの生成はすべてHuffが行ってくれます。")]),t._v(" "),a("p",[t._v("ADD_TWO()マクロのバイトコードは、メインマクロのADD_TWO()にインライン化されることになります。")]),t._v(" "),a("p",[t._v("これで、エーテルなどのライブラリや、他のコントラクトを呼び出すことができるようになるはずです")]),t._v(" "),a("p",[t._v("これで、ハフを始めるために必要な主要コンセプトと定型文のすべてを理解していただけたと思います")]),t._v(" "),a("p",[t._v("次は、「Hello, world！」という文字列を返すコントラクトを作ることで、より高度なHuffに飛び込んでいきましょう！（笑）。")])])}),[],!1,null,null,null);e.default=r.exports}}]);