(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{448:function(e,a,t){"use strict";t.r(a);var r=t(66),n=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"understanding-the-evm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#understanding-the-evm"}},[e._v("#")]),e._v(" Understanding the EVM")]),e._v(" "),t("p",[e._v("Ethereum Virtual Machine、略してEVMは、Ethereumの頭脳である。その名の通り計算エンジンであり、Microsoftの.NET Frameworkの仮想マシンや、Javaなど他のバイトコードコンパイルされたプログラミング言語のインタプリタに似ている。")]),e._v(" "),t("p",[e._v("EVMは、スマートコントラクトの展開と実行を制御するEthereumプロトコルの一部です。これは、数百万の実行可能なもの（コントラクト）を持つグローバルな分散型コンピュータに例えることができ、それぞれが独自の永久的なデータストアを備えています。")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"/evm.png",width:"640px"}})]),e._v(" "),t("figcaption",{attrs:{align:"center"}},[t("b",[e._v("Fig.1 - EVM from "),t("i",[e._v("Ethereum EVM Illustrated")]),e._v(" by Takenobu T.")])]),e._v(" "),t("h2",{attrs:{id:"technical"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#technical"}},[e._v("#")]),e._v(" Technical")]),e._v(" "),t("blockquote",[t("p",[t("em",[t("strong",[e._v("NOTE:")])]),e._v(" このチュートリアルは、Solidity にある程度慣れていて、したがってコントラクト、ステート、外部呼び出しなど、Ethereum 開発の基本を理解していることを前提にしています...")])]),e._v(" "),t("h3",{attrs:{id:"the-stack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-stack"}},[e._v("#")]),e._v(" The Stack")]),e._v(" "),t("p",[e._v("EVMは、1024項目の深さを持つスタックマシンとして動作します。各アイテムは256ビットワード（32バイト）で、これは256ビット暗号との互換性から選択されました。EVMはスタックベースのVMであるため、通常、データを先頭にPUSHし、データをPOPし、ADDやMULなどの命令を先頭にあるいくつかの値に適用します。")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://i.imgur.com/q6iEY7Z.png",width:"640px"}})]),e._v(" "),t("figcaption",{attrs:{align:"center"}},[t("b",[e._v("Fig.2 - Push/Pop Example from "),t("i",[e._v(' "Playdate with the EVM"')]),e._v(" by Femboy Capital")])]),e._v(" "),t("p",[e._v("以下は、スタックへのプッシュとスタックからのポップの例です。左側では、ある要素 "),t("code",[e._v("e")]),e._v(" がスタックの一番上に押し出され、右側では "),t("code",[e._v("e")]),e._v(" がそこから取り除かれる、つまり「ポップ」される様子を示しています。")]),e._v(" "),t("p",[t("code",[e._v("e")]),e._v(" はスタックにプッシュされた最後の要素ですが (その前に a, b, c, d があります)、pop が発生すると最初に削除される要素であることに注意することが重要です。これは、スタックは "),t("strong",[e._v("LIFO")]),e._v(" (Last In, First Out) の原則に従っており、最後に追加された要素が、最初に削除される要素になるためです。")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://i.imgur.com/SYJBUBS.png",width:"640px"}})]),e._v(" "),t("figcaption",{attrs:{align:"center"}},[t("b",[e._v("Fig.3 - MUL Opcode Example from "),t("i",[e._v(' "Playdate with the EVM"')]),e._v(" by Femboy Capital")])]),e._v(" "),t("p",[e._v("オペコードはしばしばスタック要素を入力として使用し、常に先頭の（最も最近追加された）要素を取 ります。上の例では、"),t("code",[e._v("a")]),e._v("、"),t("code",[e._v("b")]),e._v("、"),t("code",[e._v("c")]),e._v("、"),t("code",[e._v("d")]),e._v(" からなるスタックから始めます。"),t("code",[e._v("MUL")]),e._v(" オペコード（スタックの一番上にある 2 つの値を乗算する）を使用すると、"),t("code",[e._v("c")]),e._v(" と "),t("code",[e._v("d")]),e._v(" はスタックからポップされ、その積に置き換えられます。")]),e._v(" "),t("h3",{attrs:{id:"memory-and-calldata"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-and-calldata"}},[e._v("#")]),e._v(" Memory and Calldata")]),e._v(" "),t("p",[e._v("EVMでは、メモリは拡張可能なバイトアドレスの1次元配列と考えることができます。最初は空っぽです。\n読み出し、書き込み、拡張にガスがかかります。一方、Calldataは非常によく似ていますが、拡張や上書きができません。\n拡張や上書きができません。これはトランザクションのペイロードに含まれ、コントラクトコールの入力として機能する。")]),e._v(" "),t("p",[e._v("256ビットロード＆ストア。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("メモリやcalldataからの読み込みは、常に与えられたポインタの後の最初の256ビット（32バイトまたは1ワード）をアクセスします。")])]),e._v(" "),t("li",[t("p",[e._v("メモリへの格納は、常に与えられたポインタの後の最初の256ビット（32バイトまたは1ワード）にバイトを書き込みます。")])])]),e._v(" "),t("p",[e._v("メモリとcalldataは永続的ではなく、揮発性です。\n忘れ去られる。")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"/memory.png",width:"640px"}})]),e._v(" "),t("figcaption",{attrs:{align:"center"}},[t("b",[e._v("Fig.4 - Memory from "),t("i",[e._v("Ethereum EVM Illustrated")]),e._v(" by Takenobu T.")])]),e._v(" "),t("h4",{attrs:{id:"mnenomic-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mnenomic-example"}},[e._v("#")]),e._v(" Mnenomic Example")]),e._v(" "),t("div",{staticClass:"language-plaintext extra-class"},[t("pre",{pre:!0,attrs:{class:"language-plaintext"}},[t("code",[e._v("PUSH2 0x1000 // [0x1000]\nPUSH1 0x00   // [0x00, 0x1000]\nMSTORE       // []\n// Memory: 0x0000000000000000000000000000000000000000000000000000000000001000\n\nPUSH1 0x05   // [0x05]\nPUSH1 0x20   // [0x20, 0x05]\nMSTORE       // []\n// Memory: 0x00000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000005\n\nPUSH1 0x00\nMLOAD        // [0x1000]\nPUSH1 0x20\nMLOAD        // [0x05, 0x1000]\n")])])]),t("h3",{attrs:{id:"storage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#storage"}},[e._v("#")]),e._v(" Storage")]),e._v(" "),t("p",[e._v("Ethereum上のすべてのコントラクトアカウントは、Key-Valueストア内にデータを永続的に保存することができます。コントラクトストレージ\nトランザクションが実行された後、すべてのイーサリアムノードはそれに応じてコントラクトのストレージトライを更新しなければならないため、メモリよりも読み取りと書き込みに多くのコストがかかります。\nそれに応じてコントラクトのストレージトライを更新する必要があるためです。")]),e._v(" "),t("p",[e._v("メモリでやったような1次元の大きな配列を想像するのではなく、256bitのようなストレージを考えることができる→「256bit Map\n256ビットマップのように考えることができます。32バイトのキーサイズにより、合計"),t("code",[e._v("2^256")]),e._v("個のストレージスロットが存在します。")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:"/contract_acc.png",width:"320px"}})]),e._v(" "),t("figcaption",{attrs:{align:"center"}},[t("b",[e._v("Fig.5 - Contract Account from "),t("i",[e._v("Ethereum EVM Illustrated")]),e._v(" by Takenobu T.")])]),e._v(" "),t("h4",{attrs:{id:"mnenomic-example-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mnenomic-example-2"}},[e._v("#")]),e._v(" Mnenomic Example")]),e._v(" "),t("div",{staticClass:"language-plaintext extra-class"},[t("pre",{pre:!0,attrs:{class:"language-plaintext"}},[t("code",[e._v("PUSH32 0xdEaDbEeFdEaDbEeFdEaDbEeFdEaDbEeFdEaDbEeFdEaDbEeFdEaDbEeFdEaDbEeF // [dead_addr]\nPUSH1 0x00                                                                // [0x00, dead_addr]\nSSTORE                                                                    // []\n\nPUSH32 0xC0FFEE0000000000000000000000000000000000000000000000000000000000 // [coffee_addr]\nPUSH1 0x01                                                                // [0x01, coffee_addr]\nSSTORE                                                                    // []\n\n// Storage:\n// 0x00 -> deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\n// 0x01 -> c0ffee0000000000000000000000000000000000000000000000000000000000\n\nPUSH1 0x00\nSLOAD                                                                     // [dead_addr]\nPUSH1 0x01\nSLOAD                                                                     // [coffee_addr, dead_addr]\n")])])]),t("hr"),e._v(" "),t("p",[e._v("EVMの詳細については、ドキュメントの"),t("RouterLink",{attrs:{to:"/resources/overview/#other-resources"}},[e._v("Resources")]),e._v("セクションを参照してください。")],1),e._v(" "),t("p",[e._v("もし、この中に混乱するものがあっても、心配しないでください。EVMについての本を読めば基本はわかりますが、実際にアセンブリを書くことが、EVMのコツをつかむ一番の方法です（そして一番楽しいです）。それでは、簡単なプロジェクトを見てみましょう。")])])}),[],!1,null,null,null);a.default=n.exports}}]);