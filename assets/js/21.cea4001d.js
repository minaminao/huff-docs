(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{449:function(n,e,a){"use strict";a.r(e);var t=a(66),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"function-dispatching"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#function-dispatching"}},[n._v("#")]),n._v(" Function Dispatching")]),n._v(" "),a("p",[n._v("関数ディスパッチは、Huff の契約にとって基本的なものです。Solidity や Vyper とは異なり、Huff は関数のディスパッチを抽象化しません。この節では、他の言語ではディスパッチがどのように行われるのか、そして Huff ではどのように行うのかを説明します。")]),n._v(" "),a("h2",{attrs:{id:"what-is-the-problem"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-the-problem"}},[n._v("#")]),n._v(" What is the problem?")]),n._v(" "),a("p",[n._v("evmでは、コントラクトはメッセージを送信することによって対話します。ABI標準は、これらのメッセージをエンコードするための標準的な方法として存在し、関数への入力がどのようにエンコードされるべきかを扱います。この厳格なルールにより、コントラクトは互いに理解しあえるのです。また、ABI標準は、メッセージがどの関数と相互作用するつもりなのかをコントラクトに伝えます。これは、メッセージの最初に4バイトのセレクタをエンコードすることで行われます。この4バイトのセレクタは、関数の署名文字列の"),a("code",[n._v("keccak")]),n._v('の最初の4バイトです。例えば、"myFunction(address,uint256) "という文字列のkeccak256ハッシュは'),a("code",[n._v("0x451c00ddd225deee9948ba5eca26042a5ea1cc0980e5a5fb0a057f90567af5e0")]),n._v("である。つまり、最初の4バイトの"),a("code",[n._v("0x451c00dd")]),n._v("がSolidityが関数のシグネチャとして使用するものです。Solidity でインターフェースを書いたことがある人は、現在のコントラクトに、外国のコントラクトの 4 バイトのセレクタを生成する機能を提供しているだけだということに気づかないかもしれません。")]),n._v(" "),a("p",[n._v("この後は、線形ディスパッチと二分探索ディスパッチの2種類のディスパッチについて詳しく説明します。")]),n._v(" "),a("h2",{attrs:{id:"linear-dispatching"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-dispatching"}},[n._v("#")]),n._v(" Linear Dispatching")]),n._v(" "),a("p",[n._v("上記を読んで、あるいは以前に Huff のコントラクトを読んで、ディスパッチを実行する最もシンプルな方法は - 線形ルックアップであるという直感を身につけたかもしれません。この方法は、calldata メッセージから関数セレクタを抽出し、それをコントラクト内の他の関数と総当り的に比較します。")]),n._v(" "),a("p",[n._v("以下の例は、標準的なERC20トークンに対する線形ディスパッチャの外観を示したものです。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n// Interface\n#define function allowance(address,address) view returns (uint256)\n#define function approve(address,uint256) nonpayable returns ()\n#define function balanceOf(address) view returns (uint256)\n#define function DOMAIN_SEPARATOR() view returns (bytes32)\n#define function nonces(address) view returns (uint256)\n#define function permit(address,address,uint256,uint256,uint8,bytes32,bytes32) nonpayable returns ()\n#define function totalSupply() view returns (uint256)\n#define function transfer(address,uint256) nonpayable returns ()\n#define function transferFrom(address,address,uint256) nonpayable returns ()\n#define function decimals() nonpayable returns (uint256)\n#define function name() nonpayable returns (string)\n#define function symbol() nonpayable returns (string)\n\n// Function Dispatching\n#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    0x00 calldataload 0xE0 shr          // [func_sig]\n\n    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi\n    dup1 __FUNC_SIG(nonces)             eq noncesJump           jumpi\n\n    dup1 __FUNC_SIG(name)               eq nameJump             jumpi\n    dup1 __FUNC_SIG(symbol)             eq symbolJump           jumpi\n    dup1 __FUNC_SIG(decimals)           eq decimalsJump         jumpi\n    dup1 __FUNC_SIG(DOMAIN_SEPARATOR)   eq domainSeparatorJump  jumpi\n\n    dup1 __FUNC_SIG(totalSupply)        eq totalSupplyJump      jumpi\n    dup1 __FUNC_SIG(balanceOf)          eq balanceOfJump        jumpi\n    dup1 __FUNC_SIG(allowance)          eq allowanceJump        jumpi\n\n    dup1 __FUNC_SIG(transfer)           eq transferJump         jumpi\n    dup1 __FUNC_SIG(transferFrom)       eq transferFromJump     jumpi\n    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n    // Revert if no match is found.\n    0x00 dup1 revert\n\n    allowanceJump:\n        ALLOWANCE()\n    approveJump:\n        APPROVE()\n    balanceOfJump:\n        BALANCE_OF()\n    decimalsJump:\n        DECIMALS()\n    domainSeparatorJump:\n        DOMAIN_SEPARATOR()\n    nameJump:\n        NAME()\n    noncesJump:\n        NONCES()\n    permitJump:\n        PERMIT()\n    symbolJump:\n        SYMBOL()\n    totalSupplyJump:\n        TOTAL_SUPPLY()\n    transferFromJump:\n        TRANSFER_FROM()\n    transferJump:\n        TRANSFER()\n}\n")])])]),a("p",[n._v("ハフコントラクトのほぼすべてで使用する、非常に重要なコードがあります。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("0x00 calldataload 0xE0 shr\n")])])]),a("p",[n._v("これは4バイトのファンクションセレクタをスタックにロードします。"),a("code",[n._v("0x00 calldataload")]),n._v(" は 0 から始まる 32 バイトをスタックにロードします（calldata が 32 バイト未満の場合、ゼロで右詰めされます）。"),a("code",[n._v("0xE0 shr")]),n._v(" は calldata を 224 ビット右シフトし、スタックに 24 ビット（4 バイト）残します。")]),n._v(" "),a("p",[n._v("これはかなり単純なアプローチに見えますが、ほとんどの契約では、これが最も効果的であることが多いのです。これはひとつの大きな "),a("code",[n._v("if")]),n._v(" "),a("code",[n._v("else if")]),n._v(" チェーンなので、チェーンの先頭に「ホットファンクション」を配置することで最適化することができます。前方にある関数は呼び出しにかかるガス量が少なくなりますが、関数がチェーンの末端に近づくにつれ、本当に高くつくので注意が必要です。")]),n._v(" "),a("p",[n._v("この方法は素朴に見えますが、VyperやSolidity*が線形ディスパッチを実装する方法と全く同じです。もし、より安く呼び出したいのであれば、コントラクトの上位に移動させればいいだけです。")]),n._v(" "),a("p",[n._v("* Solidity は、コントラクトに含まれる関数が 4 つ以下の場合にのみ、このメソッドを実装します。")]),n._v(" "),a("p",[n._v("実装マクロの後に続く一連のジャンプラベルは何を意味するのか、不思議に思うかもしれません。良いメンタルモデルは、コントラクトの全体が MAIN マクロの中に存在することです。マクロが MAIN 内で参照されていない場合、または MAIN 内で呼び出されるマクロの中にネストされている場合、そのマクロはコントラクトに含まれないことになります。実際には、上記のコントラクトをコンパイルすると、次のようになります。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("0x[dispatcher]<allowanceJumpLabel>[ALLOWANCE MACRO]<approveJumpLabel>[APPROVE MACRO]<balanceOfJump>[BALANCE_OF MACRO] ... <transferFromLabel>[TRANSFER_FROM MACRO]<transferJump>[TRANSFER MACRO]\n")])])]),a("p",[n._v("Huffでは、すべてのマクロが1つの長いバイトコード文字列にインライン化されます(これはVyperとSolidityにも当てはまります!)。この性質上、トップレベルのマクロはすべて何らかのエスケープコード("),a("code",[n._v("return")]),n._v(", "),a("code",[n._v("stop")]),n._v(", "),a("code",[n._v("revert")]),n._v(")で終了させることが重要である。これをしないと、マクロ "),a("em",[n._v("WILL")]),n._v(" は、リターン条件が見つかるまで、次にインライン化されたマクロを実行し続けます。")]),n._v(" "),a("p",[n._v("例えば、こんな感じです。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#define function returnOne() public returns(uint256)\n#define function returnTwo() public returns(uint256)\n\n/// @notice returns the value one\n#define macro RETURN_ONE() = {\n    0x01 0x00 mstore\n    0x20 0x00 return\n}\n\n/// @notice places the value 2 onto the stack\n#define macro RETURN_TWO() = {\n    0x02\n}\n\n#define macro MAIN() = {\n    0x00 calldataload 0xE0 shr\n\n    // Dispatcher\n    dup1 __FUNC_SIG(returnOne) eq returnOneJump jumpi\n    dup1 __FUNC_SIG(returnTwo) eq returnTwoJump jumpi\n\n    // Macros\n    returnTwo:\n        RETURN_TWO()\n    returnOne:\n        RETURN_ONE()\n}\n")])])]),a("p",[n._v("上記のマクロでは、どのようなメッセージが送られてきても、常に値1を返します。マクロ "),a("code",[n._v("RETURN_TWO")]),n._v(" は終了しないので、"),a("code",[n._v("RETURN_ONE")]),n._v(" の実行にロールオーバーされ、値 1 を返して終了します。有効でない関数のシグネチャから保護するためのガードがないため、たとえディスパッチャの何もマッチしないメッセージであっても、値1を返します。")]),n._v(" "),a("p",[n._v("有効な関数セレクタが見つからない場合の対処法として、ディスパッチャとマクロのジャンプラベルの間に"),a("code",[n._v("0x00 0x00 revert")]),n._v("を挿入して、次のようにします。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#define macro MAIN() = {\n    0x00 calldataload 0xE0 shr\n\n    dup1 __FUNC_SIG(returnOne) eq returnOneJump jumpi\n    dup1 __FUNC_SIG(returnTwo) eq returnTwoJump jumpi\n\n    0x00 0x00 revert\n\n    returnTwo:\n        RETURN_TWO()\n    returnOne:\n        RETURN_ONE()\n}\n")])])]),a("p",[n._v("ハフ契約書を書くときは、この動作に注意してください。特に管理機能を扱うときは、"),a("code",[n._v("SET_OWNER()")]),n._v("マクロに遭遇すると、誰でもあなたの契約書をコントロールできるようになる可能性があります。ハフの「継承」パターンで使われるマクロ呼び出しロジックを飛び越える、より高度な方法がありますが、それは別のセクションで説明します。")]),n._v(" "),a("h2",{attrs:{id:"binary-search-dispatching"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-dispatching"}},[n._v("#")]),n._v(" Binary Search Dispatching")]),n._v(" "),a("p",[n._v("関数ディスパッチングのもう一つの方法は、正しいセレクタを見つけるためにバイナリサーチを行うことです。これは、ディスパッチコストをより予測しやすく、安定させることができるため、 多くの関数を持つコントラクトに最適です ("),a("code",[n._v("if esle")]),n._v(" チェーンのすべての分岐をチェックする必要はありません)。この方法では、関数セレクタをケチャック順に並べ、目的の関数に到達するまで、いくつかのジャンプポイントを軸に回転させます。ジャンプポイントの数は自由です。ジャンプポイントを増やせば増やすほど、ジャンプの値段は安定しますが、比較のためのガソリン代に注意が必要です。一般に、各スプリットには16〜18バイトのコードが追加されます（各ピボットポイントからジャンプがあることを忘れないでください）。")]),n._v(" "),a("p",[n._v("この方法を実行するには、関数セレクタを手作業で計算し、順番を決める必要があります。しかし、心配はいりません。これはスクリプトで簡単に行うことができます。")]),n._v(" "),a("p",[n._v("ここでは、バイナリ検索ディスパッチの実装例を示します。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n// Define Interface\n#define function allowance(address,address) view returns (uint256)\n#define function approve(address,uint256) nonpayable returns ()\n#define function balanceOf(address) view returns (uint256)\n#define function DOMAIN_SEPARATOR() view returns (bytes32)\n#define function nonces(address) view returns (uint256)\n#define function permit(address,address,uint256,uint256,uint8,bytes32,bytes32) nonpayable returns ()\n#define function totalSupply() view returns (uint256)\n#define function transfer(address,uint256) nonpayable returns ()\n#define function transferFrom(address,address,uint256) nonpayable returns ()\n#define function decimals() nonpayable returns (uint256)\n#define function name() nonpayable returns (string)\n#define function symbol() nonpayable returns (string)\n\n// Function Dispatching\n#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    // [func sig]\n    0x00 calldataload 0xE0 shr\n\n    // The function selector of the pivot (number of selectors / 2)\n    dup1 __FUNC_SIG(balanceOf) lt pivot0 jumpi\n\n        // pivot 2\n        dup1 __FUNC_SIG(totalSupply) lt pivot00 jumpi\n\n            // 1\n            dup1 __FUNC_SIG(name)               eq nameJump             jumpi\n\n            // 2\n            dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n            // 3\n            dup1 __FUNC_SIG(totalSupply)        eq totalSupplyJump      jumpi\n\n            not_found jump\n\n        pivot00:\n\n            // 4\n            dup1 __FUNC_SIG(transferFrom)       eq transferFromJump     jumpi\n\n            // 5\n            dup1 __FUNC_SIG(decimals)           eq decimalsJump         jumpi\n\n            // 6\n            dup1 __FUNC_SIG(DOMAIN_SEPARATOR)   eq domainSeparatorJump  jumpi\n\n            not_found jump\n\n    pivot0:\n\n        dup1 __FUNC_SIG(symbol) lt pivot11 jumpi\n\n\n            // 7\n            dup1 __FUNC_SIG(balanceOf)          eq balanceOfJump        jumpi\n\n            // 8\n            dup1 __FUNC_SIG(nonces)             eq noncesJump           jumpi\n\n            // 9\n            dup1 __FUNC_SIG(symbol)             eq symbolJump           jumpi\n\n            not_found jump\n\n        pivot11:\n\n            // 10\n            dup1 __FUNC_SIG(transfer)           eq transferJump         jumpi\n\n            // 11\n            dup1  __FUNC_SIG(permit)             eq permitJump           jumpi\n\n            // 12\n            dup1 __FUNC_SIG(allowance)          eq allowanceJump        jumpi\n\n    not_found:\n\n    // Revert if no match is found.\n    0x00 dup1 revert\n\n    allowanceJump:\n        ALLOWANCE()\n    approveJump:\n        APPROVE()\n    balanceOfJump:\n        BALANCE_OF()\n    decimalsJump:\n        DECIMALS()\n    domainSeparatorJump:\n        DOMAIN_SEPARATOR()\n    nameJump:\n        NAME()\n    noncesJump:\n        NONCES()\n    permitJump:\n        PERMIT()\n    symbolJump:\n        SYMBOL()\n    totalSupplyJump:\n        TOTAL_SUPPLY()\n    transferFromJump:\n        TRANSFER_FROM()\n    transferJump:\n        TRANSFER()\n}\n")])])]),a("h2",{attrs:{id:"fallback-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fallback-functions"}},[n._v("#")]),n._v(" Fallback functions")]),n._v(" "),a("p",[n._v("solidityでは、fallbackとreceiveという2つの特殊な関数があります。どちらもハフで実装するのは比較的簡単です。")]),n._v(" "),a("p",[n._v("フォールバックを実装するには、ディスパッチロジックの末尾にマクロを配置するだけです。例えば、次のフォールバック関数は常に値1を返します。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#define macro FALLBACK() = {\n    0x01 0x00 mstore\n    0x20 0x00 return\n}\n")])])]),a("p",[n._v("フォールバックとしてこれを実装するには、スイッチケースを使い切った後にこれを投げるだけでよい。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    // [func sig]\n    0x00 calldataload 0xE0 shr\n\n    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi\n\n    ...\n\n    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n    FALLBACK()\n\n   permitJump:\n        PERMIT()\n\n    ...\n\n    approveJump:\n        APPROVE()\n}\n")])])]),a("p",[n._v("フォールバックマクロとレシーブマクロの両方を実装したい場合は、以下のようにすることができます。")]),n._v(" "),a("div",{staticClass:"language-huff extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#define macro MAIN() = takes (1) returns (1) {\n    // Identify which function is being called.\n    // [func sig]\n    0x00 calldataload 0xE0 shr\n\n    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi\n\n    ...\n\n    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi\n\n    # Jump into the receive function if msg.value is not zero\n    callvalue receive jumpi\n\n    FALLBACK()\n\n    receive:\n        RECEIVE()\n\n    permitJump:\n        PERMIT()\n\n    ...\n\n    approveJump:\n        APPROVE()\n}\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);